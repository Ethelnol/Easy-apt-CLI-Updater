#!/bin/bash

declare -i true=0
declare -i false=1

declare newUIVersion="2.9.0"
declare -i ranUpdate=$false
declare optsStr=""
declare -i quiet=$false
declare mainOutput
declare -i currentStep=0

declare upgradeOutput
declare installOutput
declare removeOutput
declare withheldOutput
declare -i upgradeNum=0
declare -i installNum=0
declare -i removeNum=0
declare -i withheldNum=0
declare -a upgradeArr=()
declare -a installArr=()
declare -a removeArr=()
declare -a withheldArr=()
declare versionCheck

#returns $true if (update run successfully) or (nothing to update)
#returns $false if (update is interrupted)
main(){
	local returnBool=$false
	local tempStr=""

	echo -n "Getting list of updated packages..."
	sudo apt-get update &> /dev/null < /dev/null
	if ((! quiet)); then echo ""; else echo " Done"; fi
	(( currentStep+=1 )) #==1

	echo -n "Sorting packing information..."
	mainOutput="$(sudo apt-get upgrade --assume-no 2> /dev/null)"

	tempStr="$(ParseMultilineString \
		"Calculating upgrade..." \
		"" \
		"$mainOutput" \
	)"

	if [[ -z "$tempStr" ]]; then
		tempStr="$(ParseMultilineString \
			"Calculating upgrade... Done" \
			"" \
			"$mainOutput" \
		)"
	fi

	mainOutput="$tempStr"; unset tempStr

	SortPackageInfo
	
	if ((! quiet)); then echo ""; else echo " Done"; fi
	(( currentStep+=1 )) #==2

	versionCheck="$(\
		echo -e "$newUIVersion\n$(\
			apt -v |\
			awk '{print $2}'\
		)" |\
		sort -V |\
		tail -1 \
	)"

	if (( upgradeNum + installNum )); then Update && returnBool=$true; fi
	
	if (( removeNum )); then Remove && returnBool=$true; fi

	return $returnBool
}

#returns $true if ("-y" or "--yes" or "--assume-yes" are passed as options)
#returns $false if ("-h" or "--help" is passed as an option) 
GetOpts(){
	local -a optsArr=()
	local i
	
	read -ra optsArr <<< "$*"

	for i in "${optsArr[@]}"; do
		if [[ "$i" == "-h" ]] || [[ "$i" == "--help" ]]; then
			DisplayHelp
			exit $false
		fi

		if [[ "$i" =~ ^-[q]{1,}$ ]] || [[ "$i" == "--quiet" ]]; then
			quiet=$true
		fi

		if [[ -n "$optsStr" ]]; then optsStr+=" "; fi

		optsStr+="$i"
	done

	return $true
}

SortPackageInfo(){
	upgradeOutput="$(ParseMultilineString \
		"The following packages will be upgraded:" \
		"" \
		"$mainOutput" \
	)"
	upgradeOutput="$(UntilSpecificChar $true "$upgradeOutput")"

	installOutput="$(ParseMultilineString \
		"The following NEW packages will be installed:" \
		"" \
		"$mainOutput" \
	)"
	installOutput="$(UntilSpecificChar $false "$installOutput")"

	removeOutput="$(ParseMultilineString \
		"The following packages were automatically installed and are no longer required:" \
		"" \
		"$mainOutput" \
	)"
	if [[ -z "$removeOutput" ]]; then
		removeOutput="$(ParseMultilineString \
			"The following package was automatically installed and is no longer required:" \
			"" \
			"$mainOutput" \
		)"
	fi
	removeOutput="$(UntilSpecificChar $false "$removeOutput")"

	withheldOutput="$(ParseMultilineString \
		"The following packages have been kept back:" \
		"" \
		"$mainOutput" \
	)"
	withheldOutput="$(UntilSpecificChar $false "$withheldOutput")"

	IFS=$'\n\t ' read -rd '' -a upgradeArr  <<<"$upgradeOutput"
	IFS=$'\n\t ' read -rd '' -a installArr  <<<"$installOutput"
	IFS=$'\n\t ' read -rd '' -a removeArr   <<<"$removeOutput"
	IFS=$'\n\t ' read -rd '' -a withheldArr <<<"$withheldOutput"
	
	upgradeNum=${#upgradeArr[@]}
	installNum=${#installArr[@]}
	removeNum=${#removeArr[@]}
	withheldNum=${#withheldArr[@]}
}

#returns $true if (update run successfully)
#returns $false if (update interrupted)
Update(){
	local ranUpdate=$false
	echo -e "$upgradeNum packages are upgradable, $installNum will be newly installed\n"

	#if $version is more recent, the threshold version will be the output of the echo
	if [[ "$versionCheck" == "$newUIVersion" ]]; then
		local i

		if (( upgradeNum)); then
			echo "Upgrading:"
			for i in "${upgradeArr[@]}"; do
				echo -e "\t$i"
			done
			echo -ne "\n"
		fi

		if (( installNum )); then
			echo "Installing:"
			for i in "${installArr[@]}"; do
				echo -e "\t$i"
			done
			echo -ne "\n"
		fi

		if (( withheldNum )); then
			echo "Ignoring:"
			for i in "${withheldArr[@]}"; do
				echo -e "\t$i"
			done
			echo -ne "\n"
		fi

		unset i
	fi

	eval "sudo apt upgrade $optsStr" && ranUpdate=$true
	echo ""
	
	return $ranUpdate
}

#returns $true if (apt autoremove was prompted successfully)
#returns $false if ($numRemovable == 0)
Remove(){
	local ranRemove=$false
	if ((! removeNum)); then return $false; fi

	echo "$removeNum packages can be removed"

	if ((removeNum)); then
		if [[ "$versionCheck" == "$newUIVersion" ]]; then
			echo "Removing:"
			for i in "${removeArr[@]}"; do
				echo -e "\t$i"
			done
			echo -ne "\n"
		fi

	eval "sudo apt autoremove -qq $optsStr" && ranRemove=$true
	fi

	echo ""
	return $ranRemove
}

#prints lines between $1 and $2 non inclusively
#if $1||$2 == "", then the respective filter is skipped
#if $1||$2 not in $3, then "" is printed
ParseMultilineString(){
	if [[ -z "$3" ]]; then echo ""; return; fi

	local arrLimits=("$1" "$2")
	local arrChecks=("head" "tail")
	local str="$3"

	local limit=""
	local check=""
	local sort=""

	local -i i
	local -i j
	
	i=$(( "$(echo "$str" | wc -l)" ))

	for ((j=0;j<2;j++)); do
		limit="${arrLimits[j]}"
		
		if [[ -z "$limit" ]]; then continue; fi

		check="${arrChecks[j]}"
		sort="${arrChecks[j-1]}"

		while [[ "$(echo "$str" | eval "$check -1")" != "$limit" ]]; do
			i=$((i-1))
			str="$(echo "$str" | eval "$sort -n $i" )"
			if [[ -z "$str" ]]; then echo ""; return; fi
		done

		i=$((i-1))
		str="$(echo "$str" | eval "$sort -n $i")"
	done

	echo "$str"
	return
}

UntilSpecificChar(){
	local -i checkDigit=$1; shift
	local -a sourceArr
	local returnStr=""
	local i

	IFS=$'\n' read -rd '' -a sourceArr <<<"$*"

	#if ($1 == $true)
	if (( ! checkDigit )); then
		for i in "${sourceArr[@]}"; do
			if [[ -z "$i" ]]; then break; fi

			if [[ "${i:0:1}" != [[:digit:]] ]]; then
				if [[ -n "$returnStr" ]]; then returnStr+="\n"; fi
				returnStr+="$i"
			else break
			fi
		done
	else
		for i in "${sourceArr[@]}"; do
			if [[ -z "$i" ]]; then break; fi

			if [[ "${i:0:1}" != [[:upper:]] ]]; then
				if [[ -n "$returnStr" ]]; then returnStr+="\n"; fi
				returnStr+="$i"
			else break
			fi
		done

	fi

	echo -e "$returnStr"
	return
}

DisplayHelp(){
	echo "help [ph]"
}

#returns true if (user is root) or (user executes sudo)
#returns false if (user cannot execute sudo) or (user does not execute sudo)
SudoCheck(){	
	if [[ "$(whoami)" != "root" ]]; then
		(sudo -l &> /dev/null) && sudo echo -n "" && return $true

		echo -e "Error: requires sudo privileges\n"; return $false
	fi
	return $true
}

# shellcheck disable=SC2317
SIGINT_Interupt(){
	echo -ne "\nStopping update:"
	case $currentStep in
		0)
			echo -n "Package list retrieval"
			;;

		1)
			echo -n "Package sorting"
			;;

		2)
			echo -n "Updating/Removal process"
			;;
	esac
	echo " interrupted"
}

#has command handle SIGINT itself
trap 'SIGINT_Interupt; exit $false' SIGINT

tput civis

SudoCheck && GetOpts "$@" && main

if [[ "$?" == "$true" ]]
	then echo "Update complete"
	else echo "Update complete: Nothing to do"
fi

tput cnorm

exit $true